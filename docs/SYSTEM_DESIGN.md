## **开发设计文档 (SDD) - “ZSCE Agent”**

**版本**: 1.1
**文档状态**: 迭代中

### 1. 系统架构
本应用将作为一个独立的命令行工具（CLI Application）实现。其核心是**混合记忆系统**与**多智能体协作平台 (MCP)**。

*   **混合记忆系统**: 这是系统的基础，为Agent提供长期记忆能力，由三部分组成：
    *   **情景记忆**: 存储在本地文件系统（如 `.zswe_agent` 目录）中的任务历史、决策日志等。
    *   **语义记忆**: 通过将代码库向量化实现的RAG知识库，提供对整个项目的即时、语义级别的理解。
    *   **工作记忆**: 为单次LLM调用动态构建的、高度相关的上下文Prompt。

*   **多智能体协作平台 (MCP)**: 负责根据预设的协议，调度不同角色的Agent来完成复杂任务。

### 2. 核心组件设计
*   **`MCP_Core`**: 核心调度器。负责实现“TDD+多轮辩论+人类仲裁”的核心工作流。
*   **`ConstitutionGenerator`**: 动态生成包含项目全局信息和角色专属指令的“宪法”。
*   **`ContextCollector`**: 负责从用户指令和项目文件中收集信息，为“工作记忆”提供素材。
*   **`DeveloperAgent` (高手)**: 负责生成和修复代码。其个人宪法强调效率与创造性。
*   **`ReviewerAgent` (看门狗)**: 负责编写测试和审查代码。其个人宪法强调严苛、批判和寻找漏洞。
*   **`llm_api`**: 封装了对底层LLM的调用，并实现了基于任务类型的模型选择逻辑。
*   **`tools`**: 封装了对文件系统的原子操作。
*   **`models`**: 定义了Agent间通信用的Pydantic数据模型。

### 3. 核心工作流: TDD + 多轮辩论 + 人类仲裁
1.  **启动**: 用户输入高层指令。
2.  **生成宪法**: `ConstitutionGenerator` 扫描项目，生成包含全局信息和角色专属指令的“宪法”。
3.  **TDD - 生成测试**: `ReviewerAgent` 根据用户指令和宪法，生成一个失败的测试用例。
4.  **人类确认 (可选)**: 系统可配置为在此处暂停，请求用户确认测试用例的正确性。
5.  **TDD - 实现代码**: `DeveloperAgent` 根据用户指令、宪法和测试用例，生成实现代码。
6.  **辩论循环 (最多N轮)**:
    a. `ReviewerAgent` 审查代码，若完美则直接进入步骤7，否则生成“批判报告”。
    b. `DeveloperAgent` 根据“批判报告”调用 `fix_code` 方法，生成新版代码。
    c. 重复 a, b。
7.  **达成共识**: 如果在N轮内代码被批准，流程进入最终确认阶段。
8.  **人类仲裁**: 如果N轮后仍未批准，系统**必须暂停**，向用户展示最终分歧点（最后的代码和批判报告），请求人类介入决策。
9.  **最终确认与写入**: 在代码被AI或人类批准后，系统会最后一次请求用户授权，然后才将代码写入文件系统。

### 4. “交叉验证”与反共谋设计
为防止Agent“串通”或“共享偏见”，系统采用以下策略：
*   **信息隔离**: Agent之间只能通过`MCP_Core`和预定义的Pydantic模型通信，不能访问对方的内部思考过程。
*   **角色专属宪法**: 为不同Agent注入目标相反的指令，强制其形成对抗性的制衡关系。
*   **模型多样性 (高优先级迭代目标)**: 在未来的版本中，为`DeveloperAgent`和`ReviewerAgent`分配不同的LLM模型（如一个用Gemini Pro，一个用Claude或Llama），实现真正的“交叉验证”。

### 5. 上下文溢出管理策略
系统采用过滤、压缩和RAG相结合的策略，确保能处理远超LLM单次输入限制的大型项目。